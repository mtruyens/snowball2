// Generated by Snowball 2.0.0 - https://snowballstem.org/

package org.tartarus.snowball.ext;

import org.tartarus.snowball.Among2;

/**
 * This class implements the stemming algorithm defined by a snowball script.
 * <p>
 * Generated by Snowball 2.0.0 - https://snowballstem.org/
 * </p>
 */
@SuppressWarnings("unused")
public class swedishStemmer extends org.tartarus.snowball.SnowballStemmer {

    private static final long serialVersionUID = 1L;

private final static Among2 a_0[] = {
    new Among2("a", -1, 1),
    new Among2("arna", 0, 1),
    new Among2("erna", 0, 1),
    new Among2("heterna", 2, 1),
    new Among2("orna", 0, 1),
    new Among2("ad", -1, 1),
    new Among2("e", -1, 1),
    new Among2("ade", 6, 1),
    new Among2("ande", 6, 1),
    new Among2("arne", 6, 1),
    new Among2("are", 6, 1),
    new Among2("aste", 6, 1),
    new Among2("en", -1, 1),
    new Among2("anden", 12, 1),
    new Among2("aren", 12, 1),
    new Among2("heten", 12, 1),
    new Among2("ern", -1, 1),
    new Among2("ar", -1, 1),
    new Among2("er", -1, 1),
    new Among2("heter", 18, 1),
    new Among2("or", -1, 1),
    new Among2("s", -1, 2),
    new Among2("as", 21, 1),
    new Among2("arnas", 22, 1),
    new Among2("ernas", 22, 1),
    new Among2("ornas", 22, 1),
    new Among2("es", 21, 1),
    new Among2("ades", 26, 1),
    new Among2("andes", 26, 1),
    new Among2("ens", 21, 1),
    new Among2("arens", 29, 1),
    new Among2("hetens", 29, 1),
    new Among2("erns", 21, 1),
    new Among2("at", -1, 1),
    new Among2("andet", -1, 1),
    new Among2("het", -1, 1),
    new Among2("ast", -1, 1)
};

private final static Among2 a_1[] = {
    new Among2("dd", -1, -1),
    new Among2("gd", -1, -1),
    new Among2("nn", -1, -1),
    new Among2("dt", -1, -1),
    new Among2("gt", -1, -1),
    new Among2("kt", -1, -1),
    new Among2("tt", -1, -1)
};

private final static Among2 a_2[] = {
    new Among2("ig", -1, 1),
    new Among2("lig", 0, 1),
    new Among2("els", -1, 1),
    new Among2("fullt", -1, 3),
    new Among2("l\u00F6st", -1, 2)
};

private static final char g_v[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 32 };

private static final char g_s_ending[] = {119, 127, 149 };

private int I_x;
private int I_p1;


private boolean r_mark_regions() {
    // (, line 26
    I_p1 = limit;
    // test, line 29
    int v_1 = cursor;
    // (, line 29
    // hop, line 29
    {
        int c = cursor + 3;
        if (0 > c || c > limit)
        {
            return false;
        }
        cursor = c;
    }
    // setmark x, line 29
    I_x = cursor;
    cursor = v_1;
    // goto, line 30
    golab0: while(true)
    {
        int v_2 = cursor;
        lab1: {
            if (!(in_grouping(g_v, 97, 246)))
            {
                break lab1;
            }
            cursor = v_2;
            break golab0;
        }
        cursor = v_2;
        if (cursor >= limit)
        {
            return false;
        }
        cursor++;
    }
    // gopast, line 30
    golab2: while(true)
    {
        lab3: {
            if (!(out_grouping(g_v, 97, 246)))
            {
                break lab3;
            }
            break golab2;
        }
        if (cursor >= limit)
        {
            return false;
        }
        cursor++;
    }
    // setmark p1, line 30
    I_p1 = cursor;
    // try, line 31
    lab4: {
        // (, line 31
        if (!(I_p1 < I_x))
        {
            break lab4;
        }
        I_p1 = I_x;
    }
    return true;
}

private boolean r_main_suffix() {
    int among_var;
    // (, line 36
    // setlimit, line 37
    if (cursor < I_p1)
    {
        return false;
    }
    int v_2 = limit_backward;
    limit_backward = I_p1;
    // (, line 37
    // [, line 37
    ket = cursor;
    // substring, line 37
    among_var = find_among_b(a_0);
    if (among_var == 0)
    {
        limit_backward = v_2;
        return false;
    }
    // ], line 37
    bra = cursor;
    limit_backward = v_2;
    switch (among_var) {
        case 1:
            // (, line 44
            // delete, line 44
            slice_del();
            break;
        case 2:
            // (, line 46
            if (!(in_grouping_b(g_s_ending, 98, 121)))
            {
                return false;
            }
            // delete, line 46
            slice_del();
            break;
    }
    return true;
}

private boolean r_consonant_pair() {
    // setlimit, line 50
    if (cursor < I_p1)
    {
        return false;
    }
    int v_2 = limit_backward;
    limit_backward = I_p1;
    // (, line 50
    // and, line 52
    int v_3 = limit - cursor;
    // Among2, line 51
    if (find_among_b(a_1) == 0)
    {
        limit_backward = v_2;
        return false;
    }
    cursor = limit - v_3;
    // (, line 52
    // [, line 52
    ket = cursor;
    // next, line 52
    if (cursor <= limit_backward)
    {
        limit_backward = v_2;
        return false;
    }
    cursor--;
    // ], line 52
    bra = cursor;
    // delete, line 52
    slice_del();
    limit_backward = v_2;
    return true;
}

private boolean r_other_suffix() {
    int among_var;
    // setlimit, line 55
    if (cursor < I_p1)
    {
        return false;
    }
    int v_2 = limit_backward;
    limit_backward = I_p1;
    // (, line 55
    // [, line 56
    ket = cursor;
    // substring, line 56
    among_var = find_among_b(a_2);
    if (among_var == 0)
    {
        limit_backward = v_2;
        return false;
    }
    // ], line 56
    bra = cursor;
    switch (among_var) {
        case 1:
            // (, line 57
            // delete, line 57
            slice_del();
            break;
        case 2:
            // (, line 58
            // <-, line 58
            slice_from("l\u00F6s");
            break;
        case 3:
            // (, line 59
            // <-, line 59
            slice_from("full");
            break;
    }
    limit_backward = v_2;
    return true;
}

public boolean stem() {
    // (, line 64
    // do, line 66
    int v_1 = cursor;
    // call mark_regions, line 66
    r_mark_regions();
    cursor = v_1;
    // backwards, line 67
    limit_backward = cursor;
    cursor = limit;
    // (, line 67
    // do, line 68
    int v_2 = limit - cursor;
    // call main_suffix, line 68
    r_main_suffix();
    cursor = limit - v_2;
    // do, line 69
    int v_3 = limit - cursor;
    // call consonant_pair, line 69
    r_consonant_pair();
    cursor = limit - v_3;
    // do, line 70
    int v_4 = limit - cursor;
    // call other_suffix, line 70
    r_other_suffix();
    cursor = limit - v_4;
    cursor = limit_backward;
    return true;
}

@Override
public boolean equals( Object o ) {
    return o instanceof swedishStemmer;
}

@Override
public int hashCode() {
    return swedishStemmer.class.getName().hashCode();
}



}

